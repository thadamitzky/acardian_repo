<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>3.3. TopologyDataSubmissionService3</title><link rel="stylesheet" type="text/css" href="stylesheet.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="home" href="index.html" title="The Foglight Agent Manager Developer's Kit"/><link rel="up" href="ch03.html" title="Chapter 3. Agent Services"/><link rel="prev" href="ch03s02.html" title="3.2. LogService"/><link rel="next" href="ch03s04.html" title="3.4. Dependency Injection"/><meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.3. TopologyDataSubmissionService3</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s02.html"><img src="images/prev.png" alt="Prev"/></a> </td><th width="60%" align="center">Chapter 3. Agent Services</th><td width="20%" align="right"> <a accesskey="n" href="ch03s04.html"><img src="images/next.png" alt="Next"/></a></td></tr></table><hr/></div><img align="right" alt="[QUEST Logo]" src="images/quest_logo.gif"/><div class="section" title="3.3. TopologyDataSubmissionService3"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="agentservices-TopologyDataSubmissionService"/>3.3. TopologyDataSubmissionService3</h2></div></div></div><p>
       The <code class="function">TopologyDataSubmissionService3</code> allows agent developers to transmit data to the server
       and have it passed to the agent's CDT for transformation.
     </p><p>
       The data submission service operates in two modes, raw and cooked.
       The tooling-generated classes always use cooked mode, which instructs the
       FglAM adapter (installed in the server) to do some extra processing on the data before
       submitting it to the CDT. If you decide to use the data submission service directly, you
       must use raw mode. The data submitter you obtain from this service will be
       in raw mode by default.
     </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"/></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
       The <code class="function">TopologySubmitter3</code> interface contains a place holder field
       called <code class="varname">AGENT_ID_PLACEHOLDER</code> that you can use when submitting
       topology objects of type Agent. The Agent topology definition lists the <code class="varname">agentID</code>
       attribute as an identity property, which means that it must be submitted by the client.
       However, the numeric ID for an agent is only known to the server (and can change if the server
       is restarted). To support this, the FglAM adapter will replace any value with this
       name by changing the value name to <code class="varname">agentID</code> and providing the numeric agent ID when
       submitting the value to the CDT. The code generated by the devkit uses this place holder.
     </td></tr></table></div><p>
       Use of the data submission service in raw mode is done in 4 stages:
     </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
           Obtain the data submission service:
           </p><pre class="programlisting">TopologyDataSubmissionService3 service =
  serviceFactory.getService(TopologyDataSubmissionService3.<strong class="hl-keyword">class</strong>)</pre><p>
         </p></li><li class="listitem"><p>
           Obtain a specific submitter from the service:
           </p><pre class="programlisting">TopologySubmitter3 submitter = service.getTopologySubmitter();</pre><p>
         </p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"/></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
           The submitter is not thread-safe and it is not recommended that you cache or reuse 
           the submitter. Creating a new submitter for each submission is an inexpensive and 
           efficient operation.
         </td></tr></table></div></li><li class="listitem"><p>
         Create the nodes and value that contain the data you want to submit using
         the specific submitter.
       </p></li><li class="listitem"><p>
         Transmit the data to the server by calling
         </p><pre class="programlisting">submitter.submit();</pre><p>
       </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"/></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
           The <code class="function">submit()</code> method is now generated for all of the topology objects that are defined, 
           not just those listed in the 
           <a class="link" href="ch02s06.html#creating-agent-definition" title="2.6.4. Agent Definition">Agent Definition</a>.
       </td></tr></table></div><p>
       </p></li></ol></div><p>
       Use of the data submission service in cooked mode is very similar. This
       is how the submission service should be used with generated topology object classes:
     </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
           Obtain the data submission service:
           </p><pre class="programlisting">TopologyDataSubmissionService3 service =
  serviceFactory.getService(TopologyDataSubmissionService3.<strong class="hl-keyword">class</strong>)</pre><p>
         </p></li><li class="listitem"><p>
           Obtain a specific submitter from the service:
           </p><pre class="programlisting">TopologySubmitter3 submitter = service.getTopologySubmitter();</pre><p>
         </p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"/></td><th align="left">Warning</th></tr><tr><td align="left" valign="top">
           The submitter is not thread-safe and it is not recommended that you cache or reuse 
           the submitter. Creating a new submitter for each submission is an inexpensive and 
           efficient operation.
         </td></tr></table></div></li><li class="listitem"><p>
         Pass this submitter to the <code class="function">submit()</code> method of the generated topology 
         class instance that is at the top of the topology tree built by the agent.
       </p></li></ol></div><div class="section" title="3.3.1. Submission Meta Data"><div class="titlepage"><div><div><h3 class="title"><a id="agentservices-MetaData"/>3.3.1. Submission Meta Data</h3></div></div></div><p>
         The topology data submission service allows meta data to be included with each topology
         submission. Meta data values are automatically added to uniquely identity the host on which
         the agent is deployed to the upstream server's data processing engine as well as
         to identify verified and historical submissions. 
       </p><p>
         The type safe methods on <code class="function">TopologySubmitter3</code> should be used
         to set and get meta data values, but access to the raw values is available for advanced
         uses or to include information that the <code class="function">TopologySubmitter3</code>
         does not yet support. The upstream server does not make this meta data information
         available to the agent's CDT, so it cannot be used to pass extra information to the CDT.  
       </p><p>
         All entries in the meta data are name-value pairs, expressed as <code class="varname">String</code>s.
         The keys (names) should follow the same naming convention as the Java classes for the 
         agent and should include a full package name to ensure that they are unique. All keys
         that begin with <code class="varname">com.quest.fglam</code> are reserved and should not be changed
         or removed.
       </p><p>
         The following keys and values are automatically included with each submission and should
         not be changed.
       </p><div class="table"><a id="d0e1952"/><p class="title"><strong>Table 3.2. Pre-set Meta Data</strong></p><div class="table-contents"><table summary="Pre-set Meta Data" border="1"><colgroup><col width="50%"/><col width="50%"/></colgroup><thead><tr><th align="left">Key</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code class="function">com.quest.nitro.service.agent.id</code></td><td align="left">The ID of the agent that submitted the data. This is only set once 
                       the data reaches the server.</td></tr><tr><td align="left"><code class="function">com.quest.nitro.service.agent.host.name</code></td><td align="left">The name of the host on which the agent is running.</td></tr><tr><td align="left"><code class="function">com.quest.nitro.service.agent.host.systemId</code></td><td align="left">The systemId of the host on which the agent is running. 
                       This is not the ID of the host being monitored.</td></tr><tr><td align="left"><code class="function">com.quest.nitro.service.data.priority</code></td><td align="left">The priority of the batch of data. The value is a case-insensitive 
                       string of "high", "low" or "normal". The default is "normal".</td></tr><tr><td align="left"><code class="function">com.quest.nitro.service.data.historic_submission</code></td><td align="left">Indicates whether the submitted batch contains historic (as opposed to 
                       current) data. The case-insensitive value can be "true" or "false". 
                       The default is "false".</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" title="3.3.2. Verified Data Submissions"><div class="titlepage"><div><div><h3 class="title"><a id="agentservices-VerifiedDataSubmission"/>3.3.2. Verified Data Submissions</h3></div></div></div><p>
         The data submission service can also be used to track the status of verified data 
         submissions. To do so, developers must call the <code class="function">submitVerified(...)</code>
         method in the generated topology class, instead of the <code class="function">submit(...)</code>
         method. <code class="function">submitVerified(...)</code> returns an object that can
         be used to request the current status of the submission, as well as to request that the
         data be resubmitted.
       </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"/></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
         Verified data submissions are intended to be used sparingly and are primarily for data that
         must be accepted and processed by the FMS before the agent can continue to submit regular
         data.
       </td></tr></table></div><p>
         The object returned from the <code class="function">submitVerified(...)</code> method is used
         to check the current status of the submission. The current status of the submission
         can be obtained from the <code class="function">wasAccepted()</code>, <code class="function">wasDropped()</code>,
         or <code class="function">isInProgress())</code> methods. If none of these return true, then 
         either the status of the submission is not yet known (in-transit), or the submission
         was dropped without a notification being sent. In either case, agents should wait
         for at least three full polling cycles before they request a retransmisson of the
         data using <code class="function">resubmitData</code> or request a status update using
         <code class="function">requestStatusUpdate()</code>. After either of these methods is called,
         agents should again wait at least three full polling cycles before taking further action.
       </p><p>
         The method <code class="function">awaitStatusChange(...)</code> can be used to block in the
         agent until either that status of the submission changes, or a timeout occurs.
       </p><p>
         When using verified data submissions, there are certain caveats that need to be understood.         
       </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
           Verified submissions do not guarantee that the data will be accepted by either the Agent Manager or
           the FMS. It can still be dropped if either detects an overload condition. However,
           with verified submissions, a message will be tranmitted back to the submitting agent
           indicating that the data has been dropped.         
         </p></li><li class="listitem"><p>
           Verified submissions will be accepted regardless of the timestamp(s) in the data
           being submitted. Since it is possible for a verified submission to be dropped and
           then resubmitted at a later date, all the freshness checks on the data are disabled
           in both FglAM and the FMS for that submission.
         </p></li><li class="listitem"><p>
           Verified data submissions require more effort from both the Agent Mananger and the FMS
           and are therefore considered a limited resource. A verified submission may be rejected
           by the Agent Manager if it determines that the agent is submitting too many data samples
           too frequently or that the data samples are too large. This helps ensure that verified
           data submissions are possible for all active agents at the same time.  
         </p></li><li class="listitem"><p>
           It is possible, albiet unlikely, for a verified data submission to be dropped without
           a notification being sent. This usually indicates a serious problem in either the Agent
           Manager, the intermediate concentrator, or the FMS. Agents should be prepared to deal with this eventuality.
           Generally, verified submissions will be transmitted in the next polling cycle and the
           response received shortly after that. Agents that want to wait for a response should
           wait for at least three full polling cycles before they request a retransmission of the
           data.
         </p><p>
           The duration of a single polling cycle is currently variable, and can be determined
           using the <code class="function">UpstreamConnectionService</code>.
         </p></li></ol></div><p>
         Here is an example of one way to use verified data submissions:
         </p><pre class="programlisting">
<em class="hl-tag" style="color: green">// Submit the data and use the retuned object to track the submission.         </em>
<strong class="hl-keyword">final</strong> <strong class="hl-keyword">long</strong> now = System.currentTimeMillis();
VerifiedSubmission3 tracker = null;
<strong class="hl-keyword">try</strong> {
    tracker = sample.submitVerified(mSubmitter, mUnits, collectionFreqInMs, now);
}
<strong class="hl-keyword">catch</strong> (TopologyException te) {
    <em class="hl-tag" style="color: green">// It is also possible to check the exact nature of the exception and </em>
    <em class="hl-tag" style="color: green">// to resubmit at a later time.</em>
    <em class="hl-tag" style="color: green">// if ( te instanceof SubmittingTooFrequentlyUnsupportedException ) {</em>
    <em class="hl-tag" style="color: green">//     .. resubmit in a short time </em>
    <em class="hl-tag" style="color: green">// }</em>
    mLogger.errorUnexpected(<strong class="hl-string"><em style="color:red">"Could not submit verified topology sample"</em></strong>, te);
    <strong class="hl-keyword">return</strong>;
}

<strong class="hl-keyword">long</strong> delay = System.currentTimeMillis() - now;
<strong class="hl-keyword">final</strong> <strong class="hl-keyword">long</strong> pollingInterval = mConnectionService.getMaxPollingInterval();

<em class="hl-tag" style="color: green">// Wait at least 3 times the current maximum polling interval.</em>
<strong class="hl-keyword">final</strong> <strong class="hl-keyword">long</strong> MAX_DELAY = pollingInterval * <span class="hl-number">3</span>;
<strong class="hl-keyword">final</strong> <strong class="hl-keyword">long</strong> WAIT_TIME = pollingInterval;

<em class="hl-tag" style="color: green">// This loop will block until either:</em>
<em class="hl-tag" style="color: green">//   * the submission is known to have been accepted by the server</em>
<em class="hl-tag" style="color: green">//   * the submission has known to have been dropped</em>
<em class="hl-tag" style="color: green">//   * More than MAX_DELAY milliseconds have passed</em>
<strong class="hl-keyword">while</strong> ( ! tracker.wasAccepted() &amp;&amp; ! tracker.wasDropped() &amp;&amp; delay &lt; MAX_DELAY ) {
    mLogger.debug(<strong class="hl-string"><em style="color:red">"No confirmation of delivery after "</em></strong> + (delay / <span class="hl-number">1000.0</span>) + <strong class="hl-string"><em style="color:red">" seconds."</em></strong>);
    <strong class="hl-keyword">try</strong> {
        tracker.awaitStatusChange(WAIT_TIME, TimeUnit.MILLISECONDS);
    }
    <strong class="hl-keyword">catch</strong> (InterruptedException ie) {
        mLogger.errorUnexpected(<strong class="hl-string"><em style="color:red">"Interrupted while waiting for tracker update"</em></strong>, ie);
    }
    delay = System.currentTimeMillis() - now;
}

<em class="hl-tag" style="color: green">// Print the final results of the submission. If the sample has still not been accepted</em>
<em class="hl-tag" style="color: green">// then we could either request an update on the status (if it is not yet known) or</em>
<em class="hl-tag" style="color: green">// resubmit the data. </em>
mLogger.debug(
    <strong class="hl-string"><em style="color:red">"Waited "</em></strong> + (delay / <span class="hl-number">1000.0</span>) + <strong class="hl-string"><em style="color:red">" seconds "</em></strong> +
    <strong class="hl-string"><em style="color:red">"for the tracker. Final status:"</em></strong> + 
    (tracker.wasDropped() ? <strong class="hl-string"><em style="color:red">" dropped"</em></strong> : <strong class="hl-string"><em style="color:red">""</em></strong>) + 
    (tracker.wasAccepted() ? <strong class="hl-string"><em style="color:red">" accepted"</em></strong> : <strong class="hl-string"><em style="color:red">""</em></strong>) + 
    (tracker.isInProgress() ? <strong class="hl-string"><em style="color:red">" in-progress"</em></strong> : <strong class="hl-string"><em style="color:red">""</em></strong>) + 
    <strong class="hl-string"><em style="color:red">" ("</em></strong> + (tracker.getStatusText() != null ? tracker.getStatusText() : <strong class="hl-string"><em style="color:red">"(no status text)"</em></strong>) + <strong class="hl-string"><em style="color:red">")"</em></strong>
);

tracker.close();          
         </pre><p>
       </p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s02.html"><img src="images/prev.png" alt="Prev"/></a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html"><img src="images/up.png" alt="Up"/></a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s04.html"><img src="images/next.png" alt="Next"/></a></td></tr><tr><td width="40%" align="left" valign="top">3.2. LogService </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"/></a></td><td width="40%" align="right" valign="top"> 3.4. Dependency Injection</td></tr></table></div></body></html>