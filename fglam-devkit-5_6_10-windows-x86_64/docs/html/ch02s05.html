<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>2.5. Thread Safety</title><link rel="stylesheet" type="text/css" href="stylesheet.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="home" href="index.html" title="The Foglight Agent Manager Developer's Kit"/><link rel="up" href="ch02.html" title="Chapter 2. Creating Agents"/><link rel="prev" href="ch02s04.html" title="2.4. The Agent Environment"/><link rel="next" href="ch02s06.html" title="2.6. Writing Your First Agent"/><meta http-equiv="content-type" content="application/xhtml+xml; charset=utf-8"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.5. Thread Safety</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s04.html"><img src="images/prev.png" alt="Prev"/></a> </td><th width="60%" align="center">Chapter 2. Creating Agents</th><td width="20%" align="right"> <a accesskey="n" href="ch02s06.html"><img src="images/next.png" alt="Next"/></a></td></tr></table><hr/></div><img align="right" alt="[QUEST Logo]" src="images/quest_logo.gif"/><div class="section" title="2.5. Thread Safety"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="creating-agents-thread-safety"/>2.5. Thread Safety</h2></div></div></div><p>
          The <code class="function">allow-asynchronous-access</code> flag controls whether a devkit agent is
          single-threaded or multi-threaded. In the current version of the devkit this attribute
          is a required attribute, and the agent developer gets to decide if the agent should be single-
          or multi-threaded in behavior. In older versions of the devkit, this flag defaults to
          false (single-threaded behavior) if it is not set. The flag has to be set in the root element of the
          <span class="emphasis"><em>agent-definition</em></span> file. An example:
          
          </p><pre class="programlisting">
<b class="hl-tag" style="color: #3333FF;">&lt;agent-definition</b> <span class="hl-attribute" style="color: #993399;">xmlns</span>=<span class="hl-value" style="color: #993300">"urn:X-quest.com:glue/agent/definition/1.9"</span>
      <span class="hl-attribute" style="color: #993399;">name</span>=<span class="hl-value" style="color: #993300">"FglAMTestAgents"</span> <span class="hl-attribute" style="color: #993399;">ver</span>=<span class="hl-value" style="color: #993300">"1.0"</span>
      <span class="hl-attribute" style="color: #993399;">allow-asynchronous-access</span>=<span class="hl-value" style="color: #993300">"true"</span><b class="hl-tag" style="color: #3333FF;">&gt;</b></pre><p>
      </p><div class="section" title="2.5.1. Single-Threaded Agent Behavior"><div class="titlepage"><div><div><h3 class="title"><a id="single-threaded agents"/>2.5.1. Single-Threaded Agent Behavior</h3></div></div></div><p>
              Under the single-threaded agent model, once an agent lock is acquired it will be held until its
              processing is complete, during which time it will block any of the other scheduled tasks from completing.

              </p><pre class="programlisting">
WARN [Quartz-<span class="hl-number">20298</span>] com.quest.glue.core.services.ScheduledTimerTask - A scheduled task failed to 
  acquire the agent lock. It was not executed.
java.lang.reflect.UndeclaredThrowableException
  at $Proxy41.run(Unknown Source)
  at com.quest.glue.core.services.ScheduledTimerTask.execute(ScheduledTimerTask.java:<span class="hl-number">63</span>)
  at com.quest.glue.core.scheduler.quartz.QuartzScheduler$ScheduledTaskConcurrentJob.execute(QuartzScheduler.java:<span class="hl-number">676</span>)
  at org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="hl-number">202</span>)
  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:<span class="hl-number">886</span>)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hl-number">908</span>)
  at java.lang.Thread.run(Thread.java:<span class="hl-number">619</span>)
Caused by: java.util.concurrent.TimeoutException: Failed to acquire the agent lock because it is 
  being held by another thread(s). One of more of those threads could be hung or deadlocked.
  at com.quest.glue.core.agent.AgentInstance.acquireAgentLock(AgentInstance.java:<span class="hl-number">1232</span>)
  at com.quest.glue.core.agent.AgentInterfaceProxyHandler.invoke(AgentInterfaceProxyHandler.java:<span class="hl-number">115</span>)
  ... <span class="hl-number">7</span> more</pre><p>
                
              A 30-second timeout occurs if a thread is unable to acquire the agent's WRITE lock.
              The exception happens when one callback is holding the agent lock and another callback is
              attempting to acquire the lock and therefore times out. The second callback cannot be executed.
              This can also lead to messages being dropped and agents becoming unresponsive.
          </p></div><div class="section" title="2.5.2. Multi-Threaded Agent Behavior"><div class="titlepage"><div><div><h3 class="title"><a id="multi-threaded agents"/>2.5.2. Multi-Threaded Agent Behavior</h3></div></div></div><p>
              Under the multi-threaded model, the above problem is resolved by allowing both callbacks to
              execute simultaneously.

              Although single-threaded agents are supported, it is highly recommended that multi-threaded
              agents with proper thread-safe code be created whenever possible. This will help resolve a
              lot of the thread contentions that have been encountered in the field.
          </p><p>
              For multi-threaded behavior, FglAM can be instructed to make asynchronous method calls
              on the agent by setting the <code class="function">allow-asynchronous-access</code> flag in the agent 
              definition to true.
          </p><p>
              With this flag set, agent developers must ensure that their agents are thread safe.
              Scheduled collections, timers, callbacks, and property change notifications can arrive
              for a FglAM agent at any time. It is the responsibility of developers to handle these
              concurrent operations in a manner that is appropriate to their agent.
          </p><p>
              Generally, multiple data collections can occur simultaneously without harm.  For
              example, an agent can report statistics for multiple resources by polling each of
              them in a separate, concurrent loop. Each of these collections can take a significant
              amount of time depending on the resource and type of data being collected. To provide
              consistent data collection, other collections must be allowed to run in separate threads
              while these long collections take place. The FglAM data submission API has been
              designed with this use in mind and can safely accept data from multiple threads.
          </p><p>
              A similar situation exists when agent properties are changed. One agent might
              atomically update some member variables that will be used during the next collection,
              while another will completely tear down their data collectors and restart them. The
              former behaviour can be performed while an existing data collection is running while
              the latter would require some synchronization within the agent to prevent new
              collections from starting while the properties are updated.
          </p></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"/></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              An exception to the multi-threaded model is made regarding agent state changes. This is the set of
              methods declared in the base <code class="function">Agent</code> interface:  
              <code class="function">startDataCollection()</code>, <code class="function">stopDataCollection()</code>,
              and <code class="function">destroy()</code>. Because these are atypical, non-collection-related
              methods, FglAM will ensure that there are no other threads accessing the agent when one of
              them is called. Therefore, agent developers that are handling a
              <code class="function">stopDataCollection()</code> event need not worry whether or not there is a
              data collection method or timer callback currently executing on their agent. These are the
              only methods that are protected. All other agent code exposed to FglAM must be thread safe.
          </p></td></tr></table></div><div class="section" title="2.5.3. Agent Locks"><div class="titlepage"><div><div><h3 class="title"><a id="agent-locking-behavior"/>2.5.3. Agent Locks</h3></div></div></div><p>
              There is a single read/write lock for each agent instance. In the <span class="emphasis"><em>sync</em></span> mode, the FglAM acquires the
              write lock before any callbacks into agent code.
              The lock acquisition prefers pending write lock requests over read locks in order to provide the agent life-cycle activities
              with a higher level of responsiveness.
          </p><p>
              The timeouts for acquiring the lock types can be configured globally at startup. The default values we have set should be optimal
              for most types of Agents, but can be overridden if timeouts for lock acquisitions are prevalent. 
              To adjust the timeout values, set the appropriate property when launching FglAM:
          </p><div class="table"><a id="d0e555"/><p class="title"><strong>Table 2.3. Agent lock timeout settings</strong></p><div class="table-contents"><table summary="Agent lock timeout settings" border="1"><colgroup><col width="33%"/><col width="33%"/><col width="34%"/></colgroup><thead align="center"><tr><th align="center">Lock Type</th><th align="center">Property Name</th><th align="center">Default</th></tr></thead><tbody align="center"><tr><td align="center">WRITE</td><td align="center">-Dquest.agent.write.lock.timeout.seconds=30</td><td align="center">30 seconds</td></tr><tr><td align="center">READ</td><td align="center">-Dquest.agent.read.lock.timeout.seconds=10</td><td align="center">10 seconds</td></tr></tbody></table></div></div><br class="table-break"/><p>
              In <span class="emphasis"><em>async</em></span> mode, FglAM only acquires the write lock before calling the three agent interface methods
              (<code class="function">startDataCollection()</code>, <code class="function">stopDataCollection()</code>, and <code class="function">destroy()</code>). All other callbacks (timers, callbacks, data scheduling,
              asp updates) only acquire the read lock. This way, multiple data collections or ASP updates can run in parallel.
              However, all of them must be completed before lifecycle changes can run.
          </p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s04.html"><img src="images/prev.png" alt="Prev"/></a> </td><td width="20%" align="center"><a accesskey="u" href="ch02.html"><img src="images/up.png" alt="Up"/></a></td><td width="40%" align="right"> <a accesskey="n" href="ch02s06.html"><img src="images/next.png" alt="Next"/></a></td></tr><tr><td width="40%" align="left" valign="top">2.4. The Agent Environment </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"/></a></td><td width="40%" align="right" valign="top"> 2.6. Writing Your First Agent</td></tr></table></div></body></html>